Implemented shape ops in Java

Running random shapes to test performance

Found this...
cutRight(dafd8739) => 00100001
Is this correct? Yes it is!

pinPush(83d063f0) => 00000002
code: --------:cgRgcgcg:cbcb----:--RwRwP-, value: 83d063f0
It has an gap layer, so this is an invalid shape.
But if it was pin pushed...
- the 4th layer would disapear
- all the cystals would break as they fall because of the gap layer
- no pins would be added because the gap is on the bottom layer
The only part left would be --Rg----, which is 0002

Performance testing

ROUNDS = 20, ITERS = 10M
1279 pinPush(e3099407) => 039f0470
average time: 1289.75, 7.75 MOPS

Running a Stream in parallel is super easy...
    int[] results = IntStream.of(values).parallel().map(func).toArray();
I get over 5x improvement (for 16 virtual cores).

ROUNDS = 20, ITERS = 100M
2332 pinPush(5f23b97c) => 623f07c0
average time: 2353.90, 42.48 MOPS

Implemented Constructor

Tested with MAX_LAYERS = 1
input shapes: FLAT_4 and PIN_4
Returned 255 possible as expected

Increased to 2 layers max.

Failed with an StackOverflowError exception...

ITER #4
ONE_OPS 7 4576 > 32032
TWO_OPS 3 4938 4576 > 135577728
Exception in thread "main" java.lang.StackOverflowError
        at java.base/java.util.stream.Streams$ConcatSpliterator.estimateSize(Streams.java:743)
        at java.base/java.util.stream.Streams$ConcatSpliterator.estimateSize(Streams.java:743)

Looks like it's stuck in a recursive loop?
Actually the API docs warn about this in IntStream.concat()...
  Use caution when constructing streams from repeated concatenation.
  Accessing an element of a deeply concatenated stream can result in deep
  call chains, or even {@code StackOverflowError}.

Replaced the concat() calls with mapMulti().
Ran it for 2 layers, and got the same number of shapes as my JavaScript version!

...1-layer...

SPU 1.0
Wed Jun 12 00:33:08 PDT 2024

Max iters: 10
Max layers: 1
Input shapes
code: RrRrRrRr:--------:--------:--------, value: 0000000f
code: P-P-P-P-:--------:--------:--------, value: 000f0000

ITER #1
ONE_OPS 7 2 > 14
TWO_OPS 3 2 2 > 24
NEW 7

ITER #2
ONE_OPS 7 7 > 49
TWO_OPS 3 7 9 > 378
NEW 8

ITER #3
ONE_OPS 7 8 > 56
TWO_OPS 3 8 17 > 816
NEW 84

ITER #4
ONE_OPS 7 84 > 588
TWO_OPS 3 84 101 > 50904
NEW 26

ITER #5
ONE_OPS 7 26 > 182
TWO_OPS 3 26 127 > 19812
NEW 32

ITER #6
ONE_OPS 7 32 > 224
TWO_OPS 3 32 159 > 30528
NEW 24

ITER #7
ONE_OPS 7 24 > 168
TWO_OPS 3 24 183 > 26352
NEW 72

ITER #8
ONE_OPS 7 72 > 504
TWO_OPS 3 72 255 > 110160
DONE

Number: 255
Time: 136

...2-layers...

SPU 1.0
Wed Jun 12 00:39:30 PDT 2024

Max iters: 20
Max layers: 2
Input shapes
code: RrRrRrRr:--------:--------:--------, value: 0000000f
code: P-P-P-P-:--------:--------:--------, value: 000f0000

ITER #1
ONE_OPS 7 2 > 14
TWO_OPS 3 2 2 > 24
NEW 11

ITER #2
ONE_OPS 7 11 > 77
TWO_OPS 3 11 13 > 858
NEW 59

ITER #3
ONE_OPS 7 59 > 413
TWO_OPS 3 59 72 > 25488
NEW 290

ITER #4
ONE_OPS 7 290 > 2030
TWO_OPS 3 290 362 > 629880
NEW 4576

ITER #5
ONE_OPS 7 4576 > 32032
TWO_OPS 3 4576 4938 > 135577728
NEW 2652

ITER #6
ONE_OPS 7 2652 > 18564
TWO_OPS 3 2652 7590 > 120772080
NEW 4052

ITER #7
ONE_OPS 7 4052 > 28364
TWO_OPS 3 4052 11642 > 283040304
NEW 4066

ITER #8
ONE_OPS 7 4066 > 28462
TWO_OPS 3 4066 15708 > 383212368
NEW 18424

ITER #9
ONE_OPS 7 18424 > 128968
TWO_OPS 3 18424 34132 > 3773087808
NEW 1148

ITER #10
ONE_OPS 7 1148 > 8036
TWO_OPS 3 1148 35280 > 243008640
DONE

Number: 35280
Time: 131512

Reduced the list of Ops used, and the time went from 130 to 85 seconds.
  private static final IntUnaryOperator[] ONE_OPS = { Ops::rotateRight, Ops::cutRight, Ops::pinPush, Ops::crystal };
  private static final IntBinaryOperator[] TWO_OPS = { Ops::swapRight, Ops::stack };

Number: 35280
Time: 84936

swapRight is two cuts...
  static int swapRight(int left, int right) {
    int leftHalf = cutLeft(left);
    int rightHalf = cutRight(right);
    return leftHalf | rightHalf;
  }

Implemented fastSwapRight()...

Number: 35280
Time: 47195

Time is now 47.

Implemented fastStack() where only the bottom layer of the top shape is passed.

Number: 35280
Time: 22049

Modified fastStack() to return when the top is not 1-layer.

Number: 35280
Time: 4305

Ran 3 layers, but it quit too soon...

SPU 1.0
Wed Jun 12 02:55:06 PDT 2024

Max iters: 20
Max layers: 3
Input shapes
code: RrRrRrRr:--------:--------:--------, value: 0000000f
code: P-P-P-P-:--------:--------:--------, value: 000f0000

ITER #1
ONE_OPS 4 2 > 8
TWO_OPS 2 2 2 > 16
NEW 7

ITER #2
ONE_OPS 4 7 > 28
TWO_OPS 2 7 9 > 252
NEW 37

ITER #3
ONE_OPS 4 37 > 148
TWO_OPS 2 37 46 > 6808
NEW 157

ITER #4
ONE_OPS 4 157 > 628
TWO_OPS 2 157 203 > 127484
NEW 534

ITER #5
ONE_OPS 4 534 > 2136
TWO_OPS 2 534 737 > 1574232
NEW 2950

ITER #6
ONE_OPS 4 2950 > 11800
TWO_OPS 2 2950 3687 > 43506600
NEW 19474

ITER #7
ONE_OPS 4 19474 > 77896
TWO_OPS 2 19474 23161 > 1804149256
NEW 79589

ITER #8
ONE_OPS 4 79589 > 318356
TWO_OPS 2 79589 102750 > 32711079000
NEW 110981

ITER #9
ONE_OPS 4 110981 > 443924
TWO_OPS 2 110981 213731 > 94880320444
NEW 103146

ITER #10
ONE_OPS 4 103146 > 412584
TWO_OPS 2 103146 316877 > 130738380168
NEW 151515

ITER #11
ONE_OPS 4 151515 > 606060
TWO_OPS 2 151515 468392 > 283873655520
NEW 262661

ITER #12
ONE_OPS 4 262661 > 1050644
TWO_OPS 2 262661 731053 > 768076448132
NEW 471533

ITER #13
ONE_OPS 4 471533 > 1886132
TWO_OPS 2 471533 1202586 > 2268235937352
NEW 601791

ITER #14
ONE_OPS 4 601791 > 2407164
TWO_OPS 2 601791 1804377 > 4343431356828
NEW 889972

ITER #15
ONE_OPS 4 889972 > 3559888
TWO_OPS 2 889972 2694349 > 9591580672912
NEW 754357

ITER #16
ONE_OPS 4 754357 > 3017428
TWO_OPS 2 754357 3448706 > 10406222048168
NEW 147239

ITER #17
ONE_OPS 4 147239 > 588956
TWO_OPS 2 147239 3595945 > 2117853383420
NEW 134196

ITER #18
ONE_OPS 4 134196 > 536784
TWO_OPS 2 134196 3730141 > 2002280006544
NEW 90037

ITER #19
ONE_OPS 4 90037 > 360148
TWO_OPS 2 90037 3820178 > 1375829466344
NEW 32701

ITER #20
ONE_OPS 4 32701 > 130804
TWO_OPS 2 32701 3852879 > 503971984716
NEW 12708

Number: 3865587
Time: 64307170

The time is wrong, since the computer was off for about 6 hours.

Added stats

Test 2 layers, normal stack
cut: 35280, stack: 1388859920, rotate: 35280, pinPush 35280, crystal 35280, collapse: 53572

Test 2 layers, fastStack with crystals
cut: 35280, stack: 9642287, rotate: 35280, pinPush 35280, crystal 35280, collapse: 55930

Test 2 layers, fastStack without crystals
cut: 35280, stack: 2906894, rotate: 35280, pinPush 35280, crystal 35280, collapse: 54967

stack was called 1,388,859,920 times
35280^2 = 1,244,678,400

I would expect stack to be called 2 times the square.  Do streams dedup/memoize function calls?
Different runs call stack a differnt number of times.
Maybe (hopefully) this is due to finding different solutions to some shapes.  Like swap or stack could make the same shape.

Also, collapse is called with every cut and pinPush, so it should be just the sum of those.

Changed makeShapes to use streams and flatMap, instead of a for loop and mapMulti.
Pretty sure this avoids duplicate calls to stack and swap.
Also changed the run loop to add input shapes to allShapes after calling makeShapes instead of before.
Also removed all calls to parallel except at the very end of the chain before toArray().
It is slower now, but not sure if that's because of the metrics.

Need to try both methods.

Using allShapeStream().mapMulti(for(s1:input)) is faster than other way around.
Also faster than using flatMap of streams.  At least for small number of input shapes (~5000).

TODO
- Try implementing both methods: store new shapes before calling makeShapes, and after calling makeShapes.
- Write results to a file.
- Implement shape analysis.  E.g. Find all shapes that match a pattern, such as pin or gap under crystal.
- Remember the op and input shapes for each new shape, at least until that data is written to a file.
- Investigate parallel() some more.  It seems to only be using some of the cores, around 50% total CPU usage.
- More performance improvements, if possible.
- Find all 4-layer shapes.
- Implement cost function and find minimum soliutions.  Would need to store all solutions in memory I think.  Might need a file backed cache.
- Modify solution viewer to work with S2 ops.  Host it on github?

More optimization

Changed run method to store new shapes before calling makeShapes.
This allowed shapes to be filtered out before calling the op, rather than afterwards.
Under 2 seconds now.

Number: 35280
Time: 1915
cut: 35280, swap: 32357, stack: 2809592, rotate: 35280, pinPush 35280, crystal 35280, collapse: 56579

Further optimization might be possible:
- Optimize stack op.  DONE (2x faster)
- Optimize dropPin and dropPart.
- Use pre-filters instead of fastSwap and fastStack.  DONE (8x faster)
- Keep track of which shapes were used rather than build a set of new shapes every iter.
- Or maybe store an object with a used flag and a build op.

I think there might be a bug in dropPart and dropPin when dropping from a layer that is occupied.
For example, stack a pin on a 4-layer solid shape.
This works, but only because Shape.PIN_MASK << (4 * offset + quad) is zero when offset is 4.

3-layers...

SPU 1.0
Fri Jun 14 01:36:51 PDT 2024

Max iters: 100
Max layers: 3
Input shapes
code: RrRrRrRr:--------:--------:--------, value: 0000000f
code: P-P-P-P-:--------:--------:--------, value: 000f0000

ITER #1
ONE_OPS 4 2 > 8
TWO_OPS 2 2 2 > 8
NEW 7

ITER #2
ONE_OPS 4 7 > 28
TWO_OPS 2 7 9 > 154
NEW 37

ITER #3
ONE_OPS 4 37 > 148
TWO_OPS 2 37 46 > 4070
NEW 157

ITER #4
ONE_OPS 4 157 > 628
TWO_OPS 2 157 203 > 78186
NEW 534

ITER #5
ONE_OPS 4 534 > 2136
TWO_OPS 2 534 737 > 1003920
NEW 2950

ITER #6
ONE_OPS 4 2950 > 11800
TWO_OPS 2 2950 3687 > 26101600
NEW 19474

ITER #7
ONE_OPS 4 19474 > 77896
TWO_OPS 2 19474 23161 > 1045675904
NEW 79589

ITER #8
ONE_OPS 4 79589 > 318356
TWO_OPS 2 79589 102750 > 20042261158
NEW 110981

ITER #9
ONE_OPS 4 110981 > 443924
TWO_OPS 2 110981 213731 > 70246755722
NEW 103146

ITER #10
ONE_OPS 4 103146 > 412584
TWO_OPS 2 103146 316877 > 109460185536
NEW 151515

ITER #11
ONE_OPS 4 151515 > 606060
TWO_OPS 2 151515 468392 > 237960065070
NEW 262661

ITER #12
ONE_OPS 4 262661 > 1050644
TWO_OPS 2 262661 731053 > 630094846290
NEW 471533

ITER #13
ONE_OPS 4 471533 > 1886132
TWO_OPS 2 471533 1202586 > 1823549197174
NEW 601791

ITER #14
ONE_OPS 4 601791 > 2407164
TWO_OPS 2 601791 1804377 > 3619126541466
NEW 889972

ITER #15
ONE_OPS 4 889972 > 3559888
TWO_OPS 2 889972 2694349 > 8007480351344
NEW 754357

ITER #16
ONE_OPS 4 754357 > 3017428
TWO_OPS 2 754357 3448706 > 9268113081270
NEW 147239

ITER #17
ONE_OPS 4 147239 > 588956
TWO_OPS 2 147239 3595945 > 2074494737178
NEW 134196

ITER #18
ONE_OPS 4 134196 > 536784
TWO_OPS 2 134196 3730141 > 1966262873712
NEW 90037

ITER #19
ONE_OPS 4 90037 > 360148
TWO_OPS 2 90037 3820178 > 1359616143606
NEW 32701

ITER #20
ONE_OPS 4 32701 > 130804
TWO_OPS 2 32701 3852879 > 501833273914
NEW 12708

ITER #21
ONE_OPS 4 12708 > 50832
TWO_OPS 2 12708 3865587 > 196172531856
DONE

Number: 3865587
Time: 77989196
cut: 3865587, swap: 3222003, stack: 309229442, rotate: 3865587, pinPush 3865587, crystal 3865587, collapse: 5970101

77989196msec is 21.66 hours
minus about 6 is about 16 hours, which is 57,600,000 msec

            number   time(sec)
1-layer        255       0.055
2-layer     35,280       2.030
3-layer  3,865,587  57,600.000

Optimized stack().  Was 35 MOPS, now 65 MOPS.

Investigate why swap is different each run...

Lefts: 180, Rights: 180
Number: 35280
Time: 2077
cut: 35280, swap: 32347, stack: 2806959, rotate: 35280, pinPush 35280, crystal 35280, collapse: 57621

I would expect swap to be all the left/right combos.
That is number of half shapes squared.  180^2 = 32,400.
But swap changes each run.

When run with sequential (not parallel) streams...
cut: 35280, swap: 32400, stack: 2822400, rotate: 35280, pinPush 35280, crystal 35280, collapse: 70560

swap 180^2
stack 1680^2

Lefts: 180, Rights: 180
oneLayerNoCrystal: 80 (3^4 - 1)

swap = 32400 = 180^2 (correct)
stack = 2822400 = 35280 * 80 (correct)
collapse = 70560 (cut + pinPush)

All of these are less when running with parallel stream.  Don't know why.
I though maybe it was finding different solutions, but maybe parallel stream are not working as expected.
The collapse numbers are strange. It has nothing to do with swap or stack, so should be unaffected by the fast versions.

without parallel...
cut: 35280, swap: 32400, stack: 2822400, rotate: 35280, pinPush 35280, crystal 35280, collapse: 70560

with parallel...
cut: 35280, swap: 32373, stack: 2803965, rotate: 35280, pinPush 35280, crystal 35280, collapse: 59847
cut: 35280, swap: 32361, stack: 2804396, rotate: 35280, pinPush 35280, crystal 35280, collapse: 57882
cut: 35280, swap: 32357, stack: 2805509, rotate: 35280, pinPush 35280, crystal 35280, collapse: 56245

Maybe the stats are not thread safe?
Yep, that was it.
Fixed it with AtomicInt.

with parallel...
cut: 35280, swap: 32400, stack: 2822400, rotate: 35280, pinPush 35280, crystal 35280, collapse: 70560

Try stack with any non-crystal shape (remove 1-layer check)...

lefts: 180, rights: 180
noCrystal: 3224
oneLayerNoCrystal: 80
Number: 35280
Time: 3898
cut: 35280, swap: 32400, stack: 113742720, rotate: 35280, pinPush 35280, crystal 35280, collapse: 70560

There are 3224 (istead of 80) top layer shapes.
So stack should be 3224 * 35280 = 113,742,720.  Correct.

But, that's significantly more shapes and stack operations to perform.

I think I want to find all possible shapes first, and find solutions later.

1-layer shapes
 80 without crystals
175 with crystals

1 and 2-layer shapes
 3,224 without crystals: 
32,056 with crystals

         without    with
1-layer       80     175
2-layer    3,144  31,881
total      3,224  32,056

1-layer...
lefts: 15, rights: 15
noCrystal: 80
cut: 255, swap: 225, stack: 20400, rotate: 255, pinPush 255, crystal 255, collapse: 510

This seems to indicate there are 30 shapes that require a stacker.  I thought all 1-layer could use a swapper.
Need to find some examples.

For 1-layer, it's the shapes that swapper can't make, like half empty.  Need to use a cutter?

The 30 is the lefts and the rights.

Can you make a half shape with the swapper?
I think so, as long as both inputs have something.
But better to use a "smart swapper" that uses a cutter (one input) if needed.

Verified that fastSwap (with only left and right halves) makes the same list as swapping all shapes.
Needed to add left and right halves to the output list.
There are 180 left/right halves, so that's (180 * 180) + (2 * 180) = 180 * (180 + 2) = 32,760 shapes.

Note: swap can output the zero shape, so might need to filter that out.

Which shapes can't be made by swapper?
35,280 - 32,760 = 2520

Check all rotations of swap output, using key shapes to filter.
3168 shapes that can't be made by swapper.

Why is it different?

This appears in both the swap list and the not swap list...
value: 00000076, code: --RrRr--:RgRgRg--:--------:--------

That can be made by the swapper.
There are swap shapes that are not key values.
Fixed it by first finding the keyValues of all the swap shapes and then using that to filter all shapes.

Writing file: result.txt
Number of values written: 264

Key shapes...
Writing file: result.txt
Number of values written: 45

Reading file: allShapes2.txt
Number of values read: 35280
1-layer 255 54
2-layer 35280 5091

TODO
- Find impossible shapes, filter out invalid shapes (gap layers)

Writing file: impShapes.txt
Number of values written: 30000

Exactly 30,000 impossible 2-layer shapes
Looks like most of them are either floating layers, or pins over gaps.
Should filter those out and key map it.

Filter out more floating parts...
- pins over gaps
- pin is same as gap on top layer (can't support adjacent solids)
