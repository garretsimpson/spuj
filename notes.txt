Implemented shape ops in Java

Running random shapes to test performance

Found this...
cutRight(dafd8739) => 00100001
Is this correct? Yes it is!

pinPush(83d063f0) => 00000002
code: --------:cgRgcgcg:cbcb----:--RwRwP-, value: 83d063f0
It has an gap layer, so this is an invalid shape.
But if it was pin pushed...
- the 4th layer would disapear
- all the cystals would break as they fall because of the gap layer
- no pins would be added because the gap is on the bottom layer
The only part left would be --Rg----, which is 0002

Performance testing

ROUNDS = 20, ITERS = 10M
1279 pinPush(e3099407) => 039f0470
average time: 1289.75, 7.75 MOPS

Running a Stream in parallel is super easy...
    int[] results = IntStream.of(values).parallel().map(func).toArray();
I get over 5x improvement (for 16 virtual cores).

ROUNDS = 20, ITERS = 100M
2332 pinPush(5f23b97c) => 623f07c0
average time: 2353.90, 42.48 MOPS

Implemented Constructor

Tested with MAX_LAYERS = 1
input shapes: FLAT_4 and PIN_4
Returned 255 possible as expected

Increased to 2 layers max.

Failed with an StackOverflowError exception...

ITER #4
ONE_OPS 7 4576 > 32032
TWO_OPS 3 4938 4576 > 135577728
Exception in thread "main" java.lang.StackOverflowError
        at java.base/java.util.stream.Streams$ConcatSpliterator.estimateSize(Streams.java:743)
        at java.base/java.util.stream.Streams$ConcatSpliterator.estimateSize(Streams.java:743)

Looks like it's stuck in a recursive loop?
Actually the API docs warn about this in IntStream.concat()...
  Use caution when constructing streams from repeated concatenation.
  Accessing an element of a deeply concatenated stream can result in deep
  call chains, or even {@code StackOverflowError}.

Replaced the concat() calls with mapMulti().
Ran it for 2 layers, and got the same number of shapes as my JavaScript version!

...1-layer...

SPU 1.0
Wed Jun 12 00:33:08 PDT 2024

Max iters: 10
Max layers: 1
Input shapes
code: RrRrRrRr:--------:--------:--------, value: 0000000f
code: P-P-P-P-:--------:--------:--------, value: 000f0000

ITER #1
ONE_OPS 7 2 > 14
TWO_OPS 3 2 2 > 24
NEW 7

ITER #2
ONE_OPS 7 7 > 49
TWO_OPS 3 7 9 > 378
NEW 8

ITER #3
ONE_OPS 7 8 > 56
TWO_OPS 3 8 17 > 816
NEW 84

ITER #4
ONE_OPS 7 84 > 588
TWO_OPS 3 84 101 > 50904
NEW 26

ITER #5
ONE_OPS 7 26 > 182
TWO_OPS 3 26 127 > 19812
NEW 32

ITER #6
ONE_OPS 7 32 > 224
TWO_OPS 3 32 159 > 30528
NEW 24

ITER #7
ONE_OPS 7 24 > 168
TWO_OPS 3 24 183 > 26352
NEW 72

ITER #8
ONE_OPS 7 72 > 504
TWO_OPS 3 72 255 > 110160
DONE

Number: 255
Time: 136

...2-layers...

SPU 1.0
Wed Jun 12 00:39:30 PDT 2024

Max iters: 20
Max layers: 2
Input shapes
code: RrRrRrRr:--------:--------:--------, value: 0000000f
code: P-P-P-P-:--------:--------:--------, value: 000f0000

ITER #1
ONE_OPS 7 2 > 14
TWO_OPS 3 2 2 > 24
NEW 11

ITER #2
ONE_OPS 7 11 > 77
TWO_OPS 3 11 13 > 858
NEW 59

ITER #3
ONE_OPS 7 59 > 413
TWO_OPS 3 59 72 > 25488
NEW 290

ITER #4
ONE_OPS 7 290 > 2030
TWO_OPS 3 290 362 > 629880
NEW 4576

ITER #5
ONE_OPS 7 4576 > 32032
TWO_OPS 3 4576 4938 > 135577728
NEW 2652

ITER #6
ONE_OPS 7 2652 > 18564
TWO_OPS 3 2652 7590 > 120772080
NEW 4052

ITER #7
ONE_OPS 7 4052 > 28364
TWO_OPS 3 4052 11642 > 283040304
NEW 4066

ITER #8
ONE_OPS 7 4066 > 28462
TWO_OPS 3 4066 15708 > 383212368
NEW 18424

ITER #9
ONE_OPS 7 18424 > 128968
TWO_OPS 3 18424 34132 > 3773087808
NEW 1148

ITER #10
ONE_OPS 7 1148 > 8036
TWO_OPS 3 1148 35280 > 243008640
DONE

Number: 35280
Time: 131512

Reduced the list of Ops used, and the time went from 130 to 85 seconds.
  private static final IntUnaryOperator[] ONE_OPS = { Ops::rotateRight, Ops::cutRight, Ops::pinPush, Ops::crystal };
  private static final IntBinaryOperator[] TWO_OPS = { Ops::swapRight, Ops::stack };

Number: 35280
Time: 84936

swapRight is two cuts...
  static int swapRight(int left, int right) {
    int leftHalf = cutLeft(left);
    int rightHalf = cutRight(right);
    return leftHalf | rightHalf;
  }

Implemented fastSwapRight()...

Number: 35280
Time: 47195

Time is now 47.

Implemented fastStack() where only the bottom layer of the top shape is passed.

Number: 35280
Time: 22049

Modified fastStack() to return when the top is not 1-layer.

Number: 35280
Time: 4305

Ran 3 layers, but it quit too soon...

SPU 1.0
Wed Jun 12 02:55:06 PDT 2024

Max iters: 20
Max layers: 3
Input shapes
code: RrRrRrRr:--------:--------:--------, value: 0000000f
code: P-P-P-P-:--------:--------:--------, value: 000f0000

ITER #1
ONE_OPS 4 2 > 8
TWO_OPS 2 2 2 > 16
NEW 7

ITER #2
ONE_OPS 4 7 > 28
TWO_OPS 2 7 9 > 252
NEW 37

ITER #3
ONE_OPS 4 37 > 148
TWO_OPS 2 37 46 > 6808
NEW 157

ITER #4
ONE_OPS 4 157 > 628
TWO_OPS 2 157 203 > 127484
NEW 534

ITER #5
ONE_OPS 4 534 > 2136
TWO_OPS 2 534 737 > 1574232
NEW 2950

ITER #6
ONE_OPS 4 2950 > 11800
TWO_OPS 2 2950 3687 > 43506600
NEW 19474

ITER #7
ONE_OPS 4 19474 > 77896
TWO_OPS 2 19474 23161 > 1804149256
NEW 79589

ITER #8
ONE_OPS 4 79589 > 318356
TWO_OPS 2 79589 102750 > 32711079000
NEW 110981

ITER #9
ONE_OPS 4 110981 > 443924
TWO_OPS 2 110981 213731 > 94880320444
NEW 103146

ITER #10
ONE_OPS 4 103146 > 412584
TWO_OPS 2 103146 316877 > 130738380168
NEW 151515

ITER #11
ONE_OPS 4 151515 > 606060
TWO_OPS 2 151515 468392 > 283873655520
NEW 262661

ITER #12
ONE_OPS 4 262661 > 1050644
TWO_OPS 2 262661 731053 > 768076448132
NEW 471533

ITER #13
ONE_OPS 4 471533 > 1886132
TWO_OPS 2 471533 1202586 > 2268235937352
NEW 601791

ITER #14
ONE_OPS 4 601791 > 2407164
TWO_OPS 2 601791 1804377 > 4343431356828
NEW 889972

ITER #15
ONE_OPS 4 889972 > 3559888
TWO_OPS 2 889972 2694349 > 9591580672912
NEW 754357

ITER #16
ONE_OPS 4 754357 > 3017428
TWO_OPS 2 754357 3448706 > 10406222048168
NEW 147239

ITER #17
ONE_OPS 4 147239 > 588956
TWO_OPS 2 147239 3595945 > 2117853383420
NEW 134196

ITER #18
ONE_OPS 4 134196 > 536784
TWO_OPS 2 134196 3730141 > 2002280006544
NEW 90037

ITER #19
ONE_OPS 4 90037 > 360148
TWO_OPS 2 90037 3820178 > 1375829466344
NEW 32701

ITER #20
ONE_OPS 4 32701 > 130804
TWO_OPS 2 32701 3852879 > 503971984716
NEW 12708

Number: 3865587
Time: 64307170

The time is wrong, since the computer was off for about 6 hours.

Added stats

Test 2 layers, normal stack
cut: 35280, stack: 1388859920, rotate: 35280, pinPush 35280, crystal 35280, collapse: 53572

Test 2 layers, fastStack with crystals
cut: 35280, stack: 9642287, rotate: 35280, pinPush 35280, crystal 35280, collapse: 55930

Test 2 layers, fastStack without crystals
cut: 35280, stack: 2906894, rotate: 35280, pinPush 35280, crystal 35280, collapse: 54967

stack was called 1,388,859,920 times
35280^2 = 1,244,678,400

I would expect stack to be called 2 times the square.  Do streams dedup/memoize function calls?
Different runs call stack a differnt number of times.
Maybe (hopefully) this is due to finding different solutions to some shapes.  Like swap or stack could make the same shape.

Also, collapse is called with every cut and pinPush, so it should be just the sum of those.

Changed makeShapes to use streams and flatMap, instead of a for loop and mapMulti.
Pretty sure this avoids duplicate calls to stack and swap.
Also changed the run loop to add input shapes to allShapes after calling makeShapes instead of before.
Also removed all calls to parallel except at the very end of the chain before toArray().
It is slower now, but not sure if that's because of the metrics.

Need to try both methods.

Using allShapeStream().mapMulti(for(s1:input)) is faster than other way around.
Also faster than using flatMap of streams.  At least for small number of input shapes (~5000).

TODO
- Try implementing both methods: store new shapes before calling makeShapes, and after calling makeShapes.
- Write results to a file.
- Implement shape analysis.  E.g. Find all shapes that match a pattern, such as pin or gap under crystal.
- Remember the op and input shapes for each new shape, at least until that data is written to a file.
- Investigate parallel() some more.  It seems to only be using some of the cores, around 50% total CPU usage.
- More performance improvements, if possible.
- Find all 4-layer shapes.
- Implement cost function and find minimum soliutions.  Would need to store all solutions in memory I think.  Might need a file backed cache.
- Modify solution viewer to work with S2 ops.  Host it on github?

More optimization

Changed run method to store new shapes before calling makeShapes.
This allowed shapes to be filtered out before calling the op, rather than afterwards.
Under 2 seconds now.

Number: 35280
Time: 1915
cut: 35280, swap: 32357, stack: 2809592, rotate: 35280, pinPush 35280, crystal 35280, collapse: 56579

Further optimization might be possible:
- Optimize stack op.  DONE (2x faster)
- Optimize dropPin and dropPart.
- Use pre-filters instead of fastSwap and fastStack.  DONE (8x faster)
- Keep track of which shapes were used rather than build a set of new shapes every iter.
- Or maybe store an object with a used flag and a build op.

I think there might be a bug in dropPart and dropPin when dropping from a layer that is occupied.
For example, stack a pin on a 4-layer solid shape.
This works, but only because Shape.PIN_MASK << (4 * offset + quad) is zero when offset is 4.

3-layers...

SPU 1.0
Fri Jun 14 01:36:51 PDT 2024

Max iters: 100
Max layers: 3
Input shapes
code: RrRrRrRr:--------:--------:--------, value: 0000000f
code: P-P-P-P-:--------:--------:--------, value: 000f0000

ITER #1
ONE_OPS 4 2 > 8
TWO_OPS 2 2 2 > 8
NEW 7

ITER #2
ONE_OPS 4 7 > 28
TWO_OPS 2 7 9 > 154
NEW 37

ITER #3
ONE_OPS 4 37 > 148
TWO_OPS 2 37 46 > 4070
NEW 157

ITER #4
ONE_OPS 4 157 > 628
TWO_OPS 2 157 203 > 78186
NEW 534

ITER #5
ONE_OPS 4 534 > 2136
TWO_OPS 2 534 737 > 1003920
NEW 2950

ITER #6
ONE_OPS 4 2950 > 11800
TWO_OPS 2 2950 3687 > 26101600
NEW 19474

ITER #7
ONE_OPS 4 19474 > 77896
TWO_OPS 2 19474 23161 > 1045675904
NEW 79589

ITER #8
ONE_OPS 4 79589 > 318356
TWO_OPS 2 79589 102750 > 20042261158
NEW 110981

ITER #9
ONE_OPS 4 110981 > 443924
TWO_OPS 2 110981 213731 > 70246755722
NEW 103146

ITER #10
ONE_OPS 4 103146 > 412584
TWO_OPS 2 103146 316877 > 109460185536
NEW 151515

ITER #11
ONE_OPS 4 151515 > 606060
TWO_OPS 2 151515 468392 > 237960065070
NEW 262661

ITER #12
ONE_OPS 4 262661 > 1050644
TWO_OPS 2 262661 731053 > 630094846290
NEW 471533

ITER #13
ONE_OPS 4 471533 > 1886132
TWO_OPS 2 471533 1202586 > 1823549197174
NEW 601791

ITER #14
ONE_OPS 4 601791 > 2407164
TWO_OPS 2 601791 1804377 > 3619126541466
NEW 889972

ITER #15
ONE_OPS 4 889972 > 3559888
TWO_OPS 2 889972 2694349 > 8007480351344
NEW 754357

ITER #16
ONE_OPS 4 754357 > 3017428
TWO_OPS 2 754357 3448706 > 9268113081270
NEW 147239

ITER #17
ONE_OPS 4 147239 > 588956
TWO_OPS 2 147239 3595945 > 2074494737178
NEW 134196

ITER #18
ONE_OPS 4 134196 > 536784
TWO_OPS 2 134196 3730141 > 1966262873712
NEW 90037

ITER #19
ONE_OPS 4 90037 > 360148
TWO_OPS 2 90037 3820178 > 1359616143606
NEW 32701

ITER #20
ONE_OPS 4 32701 > 130804
TWO_OPS 2 32701 3852879 > 501833273914
NEW 12708

ITER #21
ONE_OPS 4 12708 > 50832
TWO_OPS 2 12708 3865587 > 196172531856
DONE

Number: 3865587
Time: 77989196
cut: 3865587, swap: 3222003, stack: 309229442, rotate: 3865587, pinPush 3865587, crystal 3865587, collapse: 5970101

77989196msec is 21.66 hours
minus about 6 is about 16 hours, which is 57,600,000 msec

            number   time(sec)
1-layer        255       0.055
2-layer     35,280       2.030
3-layer  3,865,587  57,600.000

Optimized stack().  Was 35 MOPS, now 65 MOPS.

Investigate why swap is different each run...

Lefts: 180, Rights: 180
Number: 35280
Time: 2077
cut: 35280, swap: 32347, stack: 2806959, rotate: 35280, pinPush 35280, crystal 35280, collapse: 57621

I would expect swap to be all the left/right combos.
That is number of half shapes squared.  180^2 = 32,400.
But swap changes each run.

When run with sequential (not parallel) streams...
cut: 35280, swap: 32400, stack: 2822400, rotate: 35280, pinPush 35280, crystal 35280, collapse: 70560

swap 180^2
stack 1680^2

Lefts: 180, Rights: 180
oneLayerNoCrystal: 80 (3^4 - 1)

swap = 32400 = 180^2 (correct)
stack = 2822400 = 35280 * 80 (correct)
collapse = 70560 (cut + pinPush)

All of these are less when running with parallel stream.  Don't know why.
I though maybe it was finding different solutions, but maybe parallel stream are not working as expected.
The collapse numbers are strange. It has nothing to do with swap or stack, so should be unaffected by the fast versions.

without parallel...
cut: 35280, swap: 32400, stack: 2822400, rotate: 35280, pinPush 35280, crystal 35280, collapse: 70560

with parallel...
cut: 35280, swap: 32373, stack: 2803965, rotate: 35280, pinPush 35280, crystal 35280, collapse: 59847
cut: 35280, swap: 32361, stack: 2804396, rotate: 35280, pinPush 35280, crystal 35280, collapse: 57882
cut: 35280, swap: 32357, stack: 2805509, rotate: 35280, pinPush 35280, crystal 35280, collapse: 56245

Maybe the stats are not thread safe?
Yep, that was it.
Fixed it with AtomicInt.

with parallel...
cut: 35280, swap: 32400, stack: 2822400, rotate: 35280, pinPush 35280, crystal 35280, collapse: 70560

Try stack with any non-crystal shape (remove 1-layer check)...

lefts: 180, rights: 180
noCrystal: 3224
oneLayerNoCrystal: 80
Number: 35280
Time: 3898
cut: 35280, swap: 32400, stack: 113742720, rotate: 35280, pinPush 35280, crystal 35280, collapse: 70560

There are 3224 (istead of 80) top layer shapes.
So stack should be 3224 * 35280 = 113,742,720.  Correct.

But, that's significantly more shapes and stack operations to perform.

I think I want to find all possible shapes first, and find solutions later.

1-layer shapes
 80 without crystals
175 with crystals

1 and 2-layer shapes
 3,224 without crystals: 
32,056 with crystals

         without    with
1-layer       80     175
2-layer    3,144  31,881
total      3,224  32,056

1-layer...
lefts: 15, rights: 15
noCrystal: 80
cut: 255, swap: 225, stack: 20400, rotate: 255, pinPush 255, crystal 255, collapse: 510

This seems to indicate there are 30 shapes that require a stacker.  I thought all 1-layer could use a swapper.
Need to find some examples.

For 1-layer, it's the shapes that swapper can't make, like half empty.  Need to use a cutter?

The 30 is the lefts and the rights.

Can you make a half shape with the swapper?
I think so, as long as both inputs have something.
But better to use a "smart swapper" that uses a cutter (one input) if needed.

Verified that fastSwap (with only left and right halves) makes the same list as swapping all shapes.
Needed to add left and right halves to the output list.
There are 180 left/right halves, so that's (180 * 180) + (2 * 180) = 180 * (180 + 2) = 32,760 shapes.

Note: swap can output the zero shape, so might need to filter that out.

Which shapes can't be made by swapper?
35,280 - 32,760 = 2520

Check all rotations of swap output, using key shapes to filter.
3168 shapes that can't be made by swapper.

Why is it different?

This appears in both the swap list and the not swap list...
value: 00000076, code: --RrRr--:RgRgRg--:--------:--------

That can be made by the swapper.
There are swap shapes that are not key values.
Fixed it by first finding the keyValues of all the swap shapes and then using that to filter all shapes.

Writing file: result.txt
Number of values written: 264

Key shapes...
Writing file: result.txt
Number of values written: 45

Reading file: allShapes2.txt
Number of values read: 35280
1-layer 255 54
2-layer 35280 5091

2-layer possible: 35280
2-layer impossible: 30256
total: 35536 (2^16) correct

TODO
- Find impossible shapes, filter out invalid shapes (gap layers)
- Find possible crystals over pins, crystals over gaps

Writing file: impShapes.txt
Number of values written: 30000

Exactly 30,000 impossible 2-layer shapes
Looks like most of them are either floating layers, or pins over gaps.
Should filter those out and key map it.

Filter out more floating parts...
- pins over gaps
- pin is same as gap on top layer (can't support adjacent solids)

crystal over pins
possible    9571  1336
impossible  5340   720

Looking at impossible shapes.
4225 key impossible shapes

- Fitler pins over gaps
- Filter out all floating (as if pins are gaps)

1203 key shapes found.  Examples...
value: 00100032, code: --Rr----:cgRg----:--------:--------
value: 00110070, code: P-------:cgRgRg--:--------:--------
value: 001100b0, code: P-------:cgRg--Rg:--------:--------

The first one has a crystal over a gap.  I know it is possible to have a gap directly under a crystal, but I think it's impossible to have a gap all the way down to the base. 
The next two have a crystal supporting two solid quarters.  These are impossible because it is impossible to swap a floating part. 
I think the check is to imagine cutting the part (and the 90 degree rotation of the part).  If something collapses in both cases, then it is impossible.

Run 3-layers...

Time: 14416
cut: 3865587, swap: 3222025, stack: 309246960, rotate: 3865587, pinPush 3865587, crystal 3865587, collapse: 7731174

OMG - 14.4 seconds.  Was 16+ hours.

Run 4-layers...

ITER #15
ONE_OPS 4 50822726 > 203290904
TWO_OPS 2 50822726 119938943 > 19216597191132320
NEW 85432162

ITER #16
ONE_OPS 4 85432162 > 341728648
TWO_OPS 2 85432162 205371105 > 55583881441927552
Exception in thread "main" java.lang.OutOfMemoryError
        at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
        at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
        at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
        at java.base/java.util.concurrent.ForkJoinTask.getThrowableException(ForkJoinTask.java:564)
        at java.base/java.util.concurrent.ForkJoinTask.reportException(ForkJoinTask.java:591)
        at java.base/java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:689)
        at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateParallel(ReduceOps.java:927)
        at java.base/java.util.stream.DistinctOps$1.reduce(DistinctOps.java:64)
        at java.base/java.util.stream.DistinctOps$1.opEvaluateParallelLazy(DistinctOps.java:110)
        at java.base/java.util.stream.AbstractPipeline.sourceSpliterator(AbstractPipeline.java:434)
        at java.base/java.util.stream.AbstractPipeline.evaluateToArrayNode(AbstractPipeline.java:260)
        at java.base/java.util.stream.IntPipeline.toArray(IntPipeline.java:562)
        at Constructor.makeShapes2(Constructor.java:151)
        at Constructor.run2(Constructor.java:168)
        at Main.makeShapes(Main.java:26)
        at Main.main(Main.java:19)
Caused by: java.lang.OutOfMemoryError: Java heap space
        at java.base/java.util.HashMap.resize(HashMap.java:702)
        at java.base/java.util.HashMap.putVal(HashMap.java:661)
        at java.base/java.util.HashMap.put(HashMap.java:610)
        at java.base/java.util.HashSet.add(HashSet.java:221)
        at java.base/java.util.stream.DistinctOps$1$$Lambda$48/0x00000222f104d8c8.accept(Unknown Source)
        at java.base/java.util.stream.ReduceOps$4ReducingSink.accept(ReduceOps.java:220)
        at java.base/java.util.stream.IntPipeline$1$1.accept(IntPipeline.java:180)
        at java.base/java.util.stream.IntPipeline$10$1.accept(IntPipeline.java:393)
        at java.base/java.util.stream.ReferencePipeline$8$1$$Lambda$50/0x00000222f104f2f0.accept(Unknown Source)
        at java.base/java.util.stream.ForEachOps$ForEachOp$OfInt.accept(ForEachOps.java:204)
        at Constructor.lambda$32(Constructor.java:142)
        at Constructor$$Lambda$42/0x00000222f1006550.accept(Unknown Source)
        at java.base/java.util.stream.IntPipeline$8$1.accept(IntPipeline.java:358)
        at java.base/java.util.stream.IntPipeline$10$1.accept(IntPipeline.java:393)
        at java.base/java.util.stream.ReferencePipeline$4$1.accept(ReferencePipeline.java:214)
        at java.base/java.util.HashMap$KeySpliterator.forEachRemaining(HashMap.java:1707)
        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
        at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
        at java.base/java.util.stream.ForEachOps$ForEachOp$OfInt.evaluateSequential(ForEachOps.java:188)
        at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
        at java.base/java.util.stream.IntPipeline.forEach(IntPipeline.java:463)
        at java.base/java.util.stream.ReferencePipeline$8$1.accept(ReferencePipeline.java:324)
        at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625)
        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
        at java.base/java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:960)
        at java.base/java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:934)
        at java.base/java.util.stream.AbstractTask.compute(AbstractTask.java:327)
        at java.base/java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:754)
        at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
        at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)

Analyze 3-layer shapes...

1-layer        255         54
2-layer      35025       5037
3-layer    3830307     497779

Same number of 2-layer shapes, so no new 2-layers found.

Possible shapes with gap under crystal similar to the one I made...
value: 02110302, code: P-Rr----:P-------:Rbcb----:--------
value: 03110302, code: P-Rr----:P-------:cbcb----:--------

First one found...
value: 01000323, code: RrRr----:--Rg----:cbRb----:--------

Vortex equivalent shapes (no gaps)...
Number of values written: 176275

TODO
- space optimization
- collect to a Set, instead of passing int[] - slower and larger
- reuse data structures and variable as much as possible - not possible when used inside a stream

With flat and pins...
ITER #20
ONE_OPS 4 32701 > 130804
TWO_OPS 2 32701 3852879 > 501833273914
NEW 12708

ITER #21
ONE_OPS 4 12708 > 50832
TWO_OPS 2 12708 3865587 > 196172531856
DONE

Time: 14038
cut: 3865587, swap: 3222025, stack: 309246960, rotate: 3865587, pinPush 3865587, crystal 3865587, collapse: 7731174

With just flats...
ITER #20
ONE_OPS 4 32701 > 130804
TWO_OPS 2 32701 3852879 > 501833273914
NEW 12708

ITER #21
ONE_OPS 4 12708 > 50832
TWO_OPS 2 12708 3865587 > 196172531856
DONE

Time: 15399
cut: 3865587, swap: 3222025, stack: 309246960, rotate: 3865587, pinPush 3865587, crystal 3865587, collapse: 7731174

Yes, you can make all 3-layer shapes with just flats (and no 4th layer)
It's probably using crystals to make pins.

TODO
- Append to results file with each iteration
- run as much of 4-layer as possible
- find solutions
- create solutions database
- update solution viewer

Maybe the Constructor can work in batches.
Like...
- read 1M (new) shapes from a file.
- perform all ops.
- append to the file.
- repeat where it left off.
- need to store all shapes in memory to check for duplicates, but only need one copy.
- old shapes would be all the known shapes?  every shape up to but not including the new shapes?

Attempt 1:
- Assume there are 100 old shapes, and batches are 10 shapes each (new shapes).
- The old shapes are the currently known shapes, but not a complete list of all possible shapes.
- So read 10, and perform...
  - One ops on each (newshape)  (10 ops)
  - Two ops on each (newshape, newshape)  (100 ops)
  - Two ops on each (oldshape, newshape)  (1000 ops)
  - Two ops on each (newshape, oldshape)  (1000 ops)
- If oldshapes contains newshapes, then there are duplicate ops calls.
- So, newshapes and oldshapes should be disjoint / separate groups.

Attempt 2:
- Read all known shapes into memory (because we need to check any result/output shapes for duplicate)
- The file could be read in rounds / chunks / batches of shapes to fit all possible op results in memory.
- Round 1: (n shapes)
- Treat the entire file (up to some limit) as the list of input shapes
- Need to perform all one ops on each, and all two ops on all pairs.
  - one ops on each (n)    // n
  - two ops on each (n, n) // n^2
- that's n^2 + n or n(n+1) ops.
- All new shapes are appended to the file, but not used in this round.
- This would find any new shapes for the first n shapes in the file.
- Rounds would be repeated until there were no new shapes found.
- Round 2: (m shapes)
- Treats the rest of the file (up to some limit) as the list of input shapes.
- Does not need to do one ops (n) or two ops (n,n) on the first n shapes.
- In this case, n is all shapes up to, but not including, m.
- Does need to do...
  - one ops on each (m)    // m
  - two ops on each (m, m) // m^2
  - two ops on each (m, n) // n*m
  - two ops on each (n, m) // n*m
- basically every two op except each (n, n) // n^2
- that's (m+n)^2 - n^2 + m ops.

Notes
- I'm inventing both rounds and batches.  Can probably be the same thing.
- (n+m)^2 = n^2 + 2nm + m^2
- 2nm + m^2 = m(2n+m)
- Could probably do the same thing in memory.
- Why is this not what the code is currently doing?
- The code is currently doing ...?

Alternative...
- Store all shapes in a fixed size database
- Use a large cache (1M or more) of the shapes
- Read from disk as needed.
- This would not have all shapes in memory, so can't check for duplicates without reading from disk.

Solution finder
- The goal is to find a solution for all shapes, perferably a minimum cost solution.
- A solution is the sequence of operations needed to build the shape from primitive shapes.
- Each shape only needs to store the one operation that was used to build it.
- The solution database could be a fixed length binary file:
  - 2^32 records, index / position would be the shape value
  - each record would have 9 bytes: op code, shape1, shape2 (optional)
- Method 1: (op priorty)
  - Operations would have a preference, try them in order and record the first one found.
  - Ideally all shapes would be in memory, but would only need store one copy of them.
  - This would work, and find a solution for all shapes, but does not account for length of the solution.
- Method 2: (build cost)
  - Need to try all possible ops for all shapes.
  - Need to record solution with accumulated cost.
  - When a lower cost is found, replace the solution.
  - Not clear if this is correct...

Example:
- flat solid and pins are the primitive (cost=0)
- pick one shape
- if shape is a primitive, then solution is primitive (cost=0), else
- try all ops (which includes using all other known shapes for 2-input ops).
  - there might be some shortcuts, like...
  - try ops in priority order (by cost) and stop when first one found.
  - need crystal maker to make crystals.
  - only stacker and pinpusher can add layers.
  - etc.
- record solution found with cost += op.cost (cost=1)
  - op costs will probably be 1 for each, but maybe crystal costs 2?

Notes
- This will find solutions to all shapes, and the cost will be 0 for primitives or 1 for every other shape.
- This is because the build found is (in most cases) not from the primitives.
- Not very useful to just find the first operation, would probably find many cycles in the build graph.
- Need a tree with primitives as the leaf nodes.
- Probably need to start with the primitives and build up from there.

YEAH! Ran 4-layers to completion...

ITER #15
ONE_OPS 4 50822726 > 203290904
TWO_OPS 2 50822726 119938943 > 19216597191132320
Writing file: data/shapes.txt
Number of values written: 85432162
NEW 85432162

ITER #16
ONE_OPS 4 85432162 > 341728648
TWO_OPS 2 85432162 205371105 > 55583881441927552
Writing file: data/shapes.txt
Number of values written: 70384893
NEW 70384893

ITER #17
ONE_OPS 4 70384893 > 281539572
TWO_OPS 2 70384893 275755998 > 67728159328109958
Writing file: data/shapes.txt
Number of values written: 26692538
NEW 26692538

ITER #18
ONE_OPS 4 26692538 > 106770152
TWO_OPS 2 26692538 302448536 > 30867492991134584
Writing file: data/shapes.txt
Number of values written: 22536443
NEW 22536443

ITER #19
ONE_OPS 4 22536443 > 90145772
TWO_OPS 2 22536443 324984979 > 28280239294174290
Writing file: data/shapes.txt
Number of values written: 14062101
NEW 14062101

ITER #20
ONE_OPS 4 14062101 > 56248404
TWO_OPS 2 14062101 339047080 > 18675371761791918
Writing file: data/shapes.txt
Number of values written: 5398979
NEW 5398979

ITER #21
ONE_OPS 4 5398979 > 21595916
TWO_OPS 2 5398979 344446059 > 7380330208210162
Writing file: data/shapes.txt
Number of values written: 1571066
NEW 1571066

ITER #22
ONE_OPS 4 1571066 > 6284264
TWO_OPS 2 1571066 346017125 > 2169526465268288
Writing file: data/shapes.txt
Number of values written: 12229
NEW 12229

ITER #23
ONE_OPS 4 12229 > 48916
TWO_OPS 2 12229 346029354 > 16926072783382
Writing file: data/shapes.txt
Number of values written: 599
NEW 599

ITER #24
ONE_OPS 4 599 > 2396
TWO_OPS 2 599 346029953 > 829087049786
Writing file: data/shapes.txt
Number of values written: 64
NEW 64

ITER #25
ONE_OPS 4 64 > 256
TWO_OPS 2 64 346030017 > 88583676160
DONE

Time: 11998226
cut: 346030017, swap: 259628769, stack: -2036339695, rotate: 346030017, pinPush 346030017, crystal 346030017, collapse: 692060034

Found 346,030,017 shapes, which is a lot less than the 2B I was predicting.
stack is negative, probably because it overflowed the AtomicInt used to count the metrics.

Time was 3.33 hours, but my computer was asleep for 1-2 hours.  Let's say total was under 2 hours.
Output file is 19.34 GB.  Not sure I can save it to GitHub.

TODO
- keep a global newShapes Set/list.
- add to the newShapes directly.
- take up to a max number shapes from newShapes.  probably 10M
- more iters, less memory
- need a method to take up to a given number of values out of a Set, into an array?
- change two ops streams to simplify/reduce number of arrays needed.

3-layer, 1 crystal

Time: 16895
cut: 4861040, swap: 3936256, stack: 388883200, rotate: 4861040, pinPush 4861040, crystal 4861040, collapse: 9722080

Is that more shapes?  was 3,865,587, now 4,861,040

Currently crystal1 makes just one crystal, even if the shape has more gaps.  But that's not how crystal maker works.
Need to have a shape with just one gap, or maybe just use a primitive that has only one crystal.

Fixed crystal1() to only make a crystal only if there is exactly one gap.

Time: 13563
cut: 3865587, swap: 3222025, stack: 309246960, rotate: 3865587, pinPush 3865587, crystal 40768, collapse: 7731174

Shape/solution database files
- a fixed length binary file with 2^32 9-byte entries would be ~ 40 GB
- It would need one 1-byte value and two 32-bit values = 9 bytes per entry.
- a text file with 1 entry per shape would be about 350M * 29 ~ 10 GB
- It would need one 1-char entry, two or three 8-char entries, and 4 1-char spearators = 20 or 29 chars per entry
- Maybe use 4 fields: cost, op, shape1, [shape2]
- The advantage of fixed length is that it could be memory mapped.  But 40GB is a lot of contiguous memory.
- The text file is actually smaller, but would need to be parsed.
- Maybe a seriallized object could be an option?

- Do I use a random access file, and write 9 bytes at a time?
- Or do I use write an entire 2^32 size Array to disk?
- I'm not even sure I can make a 2^32 size Array and be able to access all the entries.
- array index is a signed int, so 2^31-1, but might be smaller depending on JVM.
- Looks like ByteBuffer also uses an int index.
- So does an ArrayList

TODO
- Solution finder
- Make a new class for this.
- Finding any solution is simpler that finding a minimum cost solution.
- Any solution:
  - Perform all ops (like the constructor) (in priority order?)
    - priorty order means sequential performance.  How to do this in parallel?
    - maybe each op has a priory number, and lower numbers overwrite higher ones?
    - this is like cost, might do that later.
  - Find the build (op and inputs used) for each shape found (instead of just the new shape value).
  - Store the build if the shape is new (does not already have a build)
  - Or, just store all of them, they just get replaced.  Don't like this option.
- Min cost: Probably just use the same algo as before...
  - Which does not use the known list of parts
  - has a tiered todo list by cost
  - ...
- Start with primitives, which can have any cost, but zero is fine.
  - probably use 1, so that two ops cost more than one ops.
- Each op costs 1, maybe crystal costs 2.
- Put the primitives in the found and todo lists.
- take a batch out of the todo list
- perform all ops on them (in priority order?)
- two ops use shapes in batch (todo) and found lists, but not repeat them
- for each shape found:
  - compute cost: sum cost of used shapes plus cost of op
  - if it is new, store how to make it, and cost.
  - if it is old and costs less, replace the existing solution: how to make it, and cost.
  - if it is old and costs the same or more, then skip it.
  - store new shapes found in the todo list.
- can skip remaining ops when a lower cost shape found (optimization)
  - this bit is sequential.  Might need to do saving of shapes as separate pipeline?
  - This may be incorrect.  What if a later op finds a lower cost?
- store the results (incrementally ideally) in a database format
- analyze the results
  - for a given shape, output how to build it.
  - probably recursive function.
- updating and hosting the solution viewer would be awesome.

Running two ops
- Need a stream of Solutions for each (x,y)
- How do I create a stream of (x,y) pairs?
- Solved by using Stream.mapMulti()

Ran 2-layers the first time...

Time: 121131
cut: 2489392080, swap: 1244678400, stack: 1244678400, rotate: 35280, pinPush 35280, crystal 35280, collapse: 2489427360

Sorting file: BigData/shapes.db
Reading file: BigData/shapes.db
Number of values read: 35280
Writing file: BigData/shapes.db

The number of results is correct...
- rotate, pinPush, crystal are num
- swap and stack are num^2
- cut is 2*num^2 + num because 2 for each swap plus cutRight

It took 121 seconds instead of 270 msec

Sample of constructor 2-layers...
Time: 271
cut: 35280, swap: 32400, stack: 2822400, rotate: 35280, pinPush 35280, crystal 35280, collapse: 70560

- I could use fastSwap by filtering the inputs.
- The solutions would have cut before both inputs before using swap.
- When I implement cost based, the cost would be +2 in most cases.
- Might be worth it to make this faster.
- If top parts were filtered before stack, then the solutions would never put crystals on top.
- That might be worth it too.  The solutions might be longer, but they would not waste crystals.

TODO:
- Does Map.stream() have the keys?  Map does not implement stream().

Modified Solver to use only maps.

Time: 117508
cut: 2489392080, swap: 1244678400, stack: 1244678400, rotate: 35280, pinPush 35280, crystal 35280, collapse: 2489427360

Maybe a little faster, but not significantly.  Hopefully uses less memory.

It's finding solutions, but not very good ones...
00000001,SR,00cf00ff,0006000f
  00cf00ff,XX,00cf0030,00000000
    00cf0030,SR,00ff0000,000f00f0
      00ff0000,PP,000f0000,00000000
        000f0000,PR,000f0000,00000000
      000f00f0,PP,0000000f,00000000
        0000000f,PR,0000000f,00000000
  0006000f,XX,00060009,00000000
    00060009,RR,0003000c,00000000
      0003000c,SR,0000000f,000f0000
        0000000f,PR,0000000f,00000000
        000f0000,PR,000f0000,00000000

TODO
- Implement asString() and parse() for Build class.
  - maybe not, since that would make the Build class bigger.
- Solution finder: display build instructions for a given target shape.
- Try optimizing the solver.
  - Smaller Build and Solution classes
  - Can Build and Solution be combined?
  - Split makeShapes into two or more parts (one ops, two ops, etc.)  Add to newBuilds after each set of ops.
  - Prefilters for swap and stack
    - swap would always have cut first, but that should be easy to optimize aftward.
    - stack would always stack non-crystals, which would probably be the perfered solution.
    - Not sure how these would affect which solutions are found, especially when using min cost solver.
- Implement separate class for Solution list/set.  HashMap<Integer, Build> or List<Solution>?
- Implement min cost solver.
- Upgrade and host solution finder.

Last found...
File shapes2_1.db

00000001 <- SR(00cf00ff, 0006000f)
  00cf00ff <- XX(00cf0030)
    00cf0030 <- SR(00ff0000, 000f00f0)
      00ff0000 <- PP(000f0000)
        000f0000 <--
      000f00f0 <- PP(0000000f)
        0000000f <--
  0006000f <- XX(00060009)
    00060009 <- RR(0003000c)
      0003000c <- SR(0000000f, 000f0000)
        0000000f <--
        000f0000 <--

First found...
File shapes2_2.db

Find solution for: 00000001
00000001 <- SR(00cf00ff, 0006000f)
  00cf00ff <- XX(00cf0030)
    00cf0030 <- SR(00ff0000, 000f00f0)
      00ff0000 <- PP(000f0000)
        000f0000 <--
      000f00f0 <- PP(0000000f)
        0000000f <--
  0006000f <- XX(00060009)
    00060009 <- RR(0003000c)
      0003000c <- SR(0000000f, 000f0000)
        0000000f <--
        000f0000 <--

It's the same solution.

Added all types of one ops, and ran them before two_ops...
File shapes2_3.db

00000001 <- CR(00000009)
  00000009 <- RL(00000003)
    00000003 <- CR(0000000f)
      0000000f <--

Just full flats...
File shapes2_4.db

Baseline test
Time: 144447
cut: 2489427360, swap: 1244678400, stack: 1,244,678,400, rotate: 105840, pinPush 35280, crystal 35280, collapse: 2489462640

Implemented pre-filter (no crystals) on Stack op.
Time: 122874
cut: 2489427360, swap: 1244678400, stack: 113,742,720, rotate: 105840, pinPush 35280, crystal 35280, collapse: 2489462640

Well, a lot less stack ops, but still took just as long to run.

Using FastSwap (only halves) and FastStack (no crystal tops)...
File shapes2_5.db

Time: 4174
cut: 70560, swap: 64800, stack: 113742720, rotate: 105840, pinPush 35280, crystal 35280, collapse: 105840

- total = 35,280
- halves = 180
- cut = 2 * total
- swap = 2 * halves^2
- stack = 2334 * total
- rotate = 3 * total
- pinPush = total
- crystal = total
- collapse = cut + pinPush = 3 * total

Running solutions for 3-layers...
- It is taking hours to complete.
- CPU is less than 20%.
- not sure parallel stream are working as they should.
- might try adding parallelStream() in some cases.

Stopped it early (4+ hours)
TODO 1797010
ITER #25
ONE_OPS 7 100000 > 700000
TWO_OPS 3 100000 1884465 > 1160679000000

Did not find all the shapes yet.
Maybe need a check - if total number of shapes reaches the known value, then copy all shapes over and quit early.

